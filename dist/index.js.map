{"version":3,"sources":["../src/guards/index.ts","../src/compare/index.ts","../src/convert/index.ts","../src/index.ts"],"names":["Temporal"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Type guards for Temporal types\n *\n * These allow runtime type checking and enable TypeScript narrowing.\n */\n\nimport { Temporal } from \"temporal-polyfill\";\nimport type {\n  DateLike,\n  Instant,\n  PlainDate,\n  PlainDateTime,\n  PlainTime,\n  TimeLike,\n  ZonedDateTime,\n} from \"../types/index.js\";\n\n/**\n * Type guard for Temporal.PlainDate\n */\nexport function isPlainDate(value: unknown): value is PlainDate {\n  return value instanceof Temporal.PlainDate;\n}\n\n/**\n * Type guard for Temporal.PlainDateTime\n */\nexport function isPlainDateTime(value: unknown): value is PlainDateTime {\n  return value instanceof Temporal.PlainDateTime;\n}\n\n/**\n * Type guard for Temporal.PlainTime\n */\nexport function isPlainTime(value: unknown): value is PlainTime {\n  return value instanceof Temporal.PlainTime;\n}\n\n/**\n * Type guard for Temporal.ZonedDateTime\n */\nexport function isZonedDateTime(value: unknown): value is ZonedDateTime {\n  return value instanceof Temporal.ZonedDateTime;\n}\n\n/**\n * Type guard for Temporal.Instant\n */\nexport function isInstant(value: unknown): value is Instant {\n  return value instanceof Temporal.Instant;\n}\n\n/**\n * Type guard for DateLike types (PlainDate, PlainDateTime, ZonedDateTime)\n */\nexport function isDateLike(value: unknown): value is DateLike {\n  return (\n    value instanceof Temporal.PlainDate ||\n    value instanceof Temporal.PlainDateTime ||\n    value instanceof Temporal.ZonedDateTime\n  );\n}\n\n/**\n * Type guard for TimeLike types (PlainTime, PlainDateTime, ZonedDateTime)\n */\nexport function isTimeLike(value: unknown): value is TimeLike {\n  return (\n    value instanceof Temporal.PlainTime ||\n    value instanceof Temporal.PlainDateTime ||\n    value instanceof Temporal.ZonedDateTime\n  );\n}\n","/**\n * Comparison functions for Temporal date/time types\n * @module compare\n */\n\nimport { Temporal } from 'temporal-polyfill';\nimport type { DateLike } from '../types/index.js';\n\n/**\n * Checks if the first date/time is before the second.\n *\n * Uses the appropriate compare method based on the type.\n *\n * @param a - First date/time to compare\n * @param b - Second date/time to compare\n * @returns true if a is before b\n *\n * @example\n * ```ts\n * import { isBefore } from 'temporal-kit';\n *\n * const date1 = Temporal.PlainDate.from('2025-01-01');\n * const date2 = Temporal.PlainDate.from('2025-12-31');\n *\n * isBefore(date1, date2); // true\n * ```\n */\nexport function isBefore(a: DateLike, b: DateLike): boolean {\n\t// Use PlainDateTime.compare for DateTime, ZonedDateTime.compare for ZonedDateTime, else PlainDate.compare\n\tif ('hour' in a && 'hour' in b) {\n\t\tif ('timeZoneId' in a && 'timeZoneId' in b) {\n\t\t\treturn Temporal.ZonedDateTime.compare(a, b) < 0;\n\t\t}\n\t\treturn Temporal.PlainDateTime.compare(a, b) < 0;\n\t}\n\treturn Temporal.PlainDate.compare(a, b) < 0;\n}\n\n/**\n * Checks if the first date/time is after the second.\n *\n * Uses the appropriate compare method based on the type.\n *\n * @param a - First date/time to compare\n * @param b - Second date/time to compare\n * @returns true if a is after b\n *\n * @example\n * ```ts\n * import { isAfter } from 'temporal-kit';\n *\n * const date1 = Temporal.PlainDate.from('2025-12-31');\n * const date2 = Temporal.PlainDate.from('2025-01-01');\n *\n * isAfter(date1, date2); // true\n * ```\n */\nexport function isAfter(a: DateLike, b: DateLike): boolean {\n\tif ('hour' in a && 'hour' in b) {\n\t\tif ('timeZoneId' in a && 'timeZoneId' in b) {\n\t\t\treturn Temporal.ZonedDateTime.compare(a, b) > 0;\n\t\t}\n\t\treturn Temporal.PlainDateTime.compare(a, b) > 0;\n\t}\n\treturn Temporal.PlainDate.compare(a, b) > 0;\n}\n\n/**\n * Checks if two date/times are equal.\n *\n * Uses the appropriate compare method based on the type.\n *\n * @param a - First date/time to compare\n * @param b - Second date/time to compare\n * @returns true if a equals b\n *\n * @example\n * ```ts\n * import { isSame } from 'temporal-kit';\n *\n * const date1 = Temporal.PlainDate.from('2025-11-30');\n * const date2 = Temporal.PlainDate.from('2025-11-30');\n *\n * isSame(date1, date2); // true\n * ```\n */\nexport function isSame(a: DateLike, b: DateLike): boolean {\n\tif ('hour' in a && 'hour' in b) {\n\t\tif ('timeZoneId' in a && 'timeZoneId' in b) {\n\t\t\treturn Temporal.ZonedDateTime.compare(a, b) === 0;\n\t\t}\n\t\treturn Temporal.PlainDateTime.compare(a, b) === 0;\n\t}\n\treturn Temporal.PlainDate.compare(a, b) === 0;\n}\n\n/**\n * Returns the earliest (minimum) date/time from the provided values.\n *\n * @param dates - Array of dates to compare\n * @returns The earliest date\n * @throws {TypeError} If the array is empty\n *\n * @example\n * ```ts\n * import { min } from 'temporal-kit';\n *\n * const dates = [\n *   Temporal.PlainDate.from('2025-03-15'),\n *   Temporal.PlainDate.from('2025-01-01'),\n *   Temporal.PlainDate.from('2025-12-31')\n * ];\n *\n * min(dates); // 2025-01-01\n * ```\n */\nexport function min<T extends DateLike>(dates: T[]): T {\n\tif (dates.length === 0) {\n\t\tthrow new TypeError('Cannot find min of empty array');\n\t}\n\n\treturn dates.reduce((earliest, current) => {\n\t\t// Use appropriate compare based on type\n\t\tif ('hour' in current && 'hour' in earliest) {\n\t\t\tif ('timeZoneId' in current && 'timeZoneId' in earliest) {\n\t\t\t\treturn Temporal.ZonedDateTime.compare(current, earliest) < 0 ? current : earliest;\n\t\t\t}\n\t\t\treturn Temporal.PlainDateTime.compare(current, earliest) < 0 ? current : earliest;\n\t\t}\n\t\treturn Temporal.PlainDate.compare(current, earliest) < 0 ? current : earliest;\n\t});\n}\n\n/**\n * Returns the latest (maximum) date/time from the provided values.\n *\n * @param dates - Array of dates to compare\n * @returns The latest date\n * @throws {TypeError} If the array is empty\n *\n * @example\n * ```ts\n * import { max } from 'temporal-kit';\n *\n * const dates = [\n *   Temporal.PlainDate.from('2025-03-15'),\n *   Temporal.PlainDate.from('2025-01-01'),\n *   Temporal.PlainDate.from('2025-12-31')\n * ];\n *\n * max(dates); // 2025-12-31\n * ```\n */\nexport function max<T extends DateLike>(dates: T[]): T {\n\tif (dates.length === 0) {\n\t\tthrow new TypeError('Cannot find max of empty array');\n\t}\n\n\treturn dates.reduce((latest, current) => {\n\t\t// Use appropriate compare based on type\n\t\tif ('hour' in current && 'hour' in latest) {\n\t\t\tif ('timeZoneId' in current && 'timeZoneId' in latest) {\n\t\t\t\treturn Temporal.ZonedDateTime.compare(current, latest) > 0 ? current : latest;\n\t\t\t}\n\t\t\treturn Temporal.PlainDateTime.compare(current, latest) > 0 ? current : latest;\n\t\t}\n\t\treturn Temporal.PlainDate.compare(current, latest) > 0 ? current : latest;\n\t});\n}\n","import { Temporal } from \"temporal-polyfill\";\nimport type { DateLike } from \"../types/index.js\";\n\n/**\n * Get current date and time in the system timezone\n * @returns Current ZonedDateTime in system timezone\n * @example\n * const now = now()\n * console.log(now.toString()) // \"2025-11-30T15:30:00+01:00[Europe/Berlin]\"\n */\nexport function now(): Temporal.ZonedDateTime {\n\treturn Temporal.Now.zonedDateTimeISO();\n}\n\n/**\n * Parse an ISO 8601 string into the appropriate Temporal type\n * @param isoString - ISO 8601 formatted string\n * @returns PlainDate, PlainDateTime, ZonedDateTime, or Instant depending on the format\n * @example\n * fromISO('2025-11-30') // PlainDate\n * fromISO('2025-11-30T15:30:00') // PlainDateTime\n * fromISO('2025-11-30T15:30:00+01:00[Europe/Berlin]') // ZonedDateTime\n * fromISO('2025-11-30T14:30:00Z') // Instant\n */\nexport function fromISO(\n\tisoString: string,\n):\n\t| Temporal.PlainDate\n\t| Temporal.PlainDateTime\n\t| Temporal.ZonedDateTime\n\t| Temporal.Instant {\n\t// Try to detect format by presence of timezone/offset indicators\n\tif (isoString.includes(\"[\") || /[+-]\\d{2}:\\d{2}$/.test(isoString)) {\n\t\t// Has timezone identifier or offset\n\t\treturn Temporal.ZonedDateTime.from(isoString);\n\t}\n\n\tif (isoString.endsWith(\"Z\") || /[+-]\\d{2}:\\d{2}/.test(isoString)) {\n\t\t// Has Z or offset but no timezone - treat as Instant\n\t\treturn Temporal.Instant.from(isoString);\n\t}\n\n\tif (isoString.includes(\"T\")) {\n\t\t// Has time component but no timezone\n\t\treturn Temporal.PlainDateTime.from(isoString);\n\t}\n\n\t// Just a date\n\treturn Temporal.PlainDate.from(isoString);\n}\n\n/**\n * Convert any DateLike to PlainDate (discards time and timezone info)\n * @param date - PlainDate, PlainDateTime, or ZonedDateTime\n * @returns PlainDate representing the calendar date\n * @example\n * const zdt = Temporal.ZonedDateTime.from('2025-11-30T15:30:00+01:00[Europe/Berlin]')\n * const date = toPlainDate(zdt) // 2025-11-30\n */\nexport function toPlainDate(date: DateLike): Temporal.PlainDate {\n\tif (date instanceof Temporal.PlainDate) {\n\t\treturn date;\n\t}\n\treturn date.toPlainDate();\n}\n\n/**\n * Convert PlainDateTime or ZonedDateTime to PlainDateTime (discards timezone)\n * For PlainDate, you must provide an explicit time to convert to PlainDateTime\n * @param date - PlainDateTime or ZonedDateTime\n * @returns PlainDateTime\n * @example\n * const zdt = Temporal.ZonedDateTime.from('2025-11-30T15:30:00+01:00[Europe/Berlin]')\n * const pdt = toPlainDateTime(zdt) // 2025-11-30T15:30:00\n */\nexport function toPlainDateTime(\n\tdate: Temporal.PlainDateTime | Temporal.ZonedDateTime,\n): Temporal.PlainDateTime {\n\tif (date instanceof Temporal.PlainDateTime) {\n\t\treturn date;\n\t}\n\treturn date.toPlainDateTime();\n}\n\n/**\n * Convert any DateLike to ZonedDateTime\n * @param date - PlainDate, PlainDateTime, or ZonedDateTime\n * @param timeZone - IANA timezone identifier (required for PlainDate and PlainDateTime)\n * @returns ZonedDateTime in the specified (or existing) timezone\n * @example\n * const date = Temporal.PlainDate.from('2025-11-30')\n * const zdt = toZonedDateTime(date, 'Europe/Berlin') // 2025-11-30T00:00:00+01:00[Europe/Berlin]\n *\n * const pdt = Temporal.PlainDateTime.from('2025-11-30T15:30:00')\n * const zdt2 = toZonedDateTime(pdt, 'America/New_York') // 2025-11-30T15:30:00-05:00[America/New_York]\n */\nexport function toZonedDateTime(\n\tdate: DateLike,\n\ttimeZone?: string,\n): Temporal.ZonedDateTime {\n\tif (date instanceof Temporal.ZonedDateTime) {\n\t\t// If already ZonedDateTime, optionally convert to different timezone\n\t\treturn timeZone ? date.withTimeZone(timeZone) : date;\n\t}\n\n\tif (!timeZone) {\n\t\tthrow new TypeError(\n\t\t\t\"timeZone is required when converting PlainDate or PlainDateTime to ZonedDateTime\",\n\t\t);\n\t}\n\n\treturn date.toZonedDateTime(timeZone);\n}\n","/**\n * temporal-kit - Main entry point (no polyfill)\n *\n * This entry expects Temporal to be available natively.\n * If you need polyfill support, use 'temporal-kit/polyfilled' instead.\n */\n\n// Check if Temporal is available\nif (typeof (globalThis as { Temporal?: unknown }).Temporal === \"undefined\") {\n  throw new Error(\n    \"Temporal is not available. \" +\n      \"Either use a modern environment with native Temporal support, \" +\n      \"or import from 'temporal-kit/polyfilled' to automatically load the polyfill.\",\n  );\n}\n\n// Re-export guards\nexport * from \"./guards/index.js\";\n// Re-export compare functions\nexport * from \"./compare/index.js\";\n// Re-export convert functions\nexport * from \"./convert/index.js\";\n// Re-export types\nexport type * from \"./types/index.js\";\n\n// Placeholder exports for modules we'll implement next\n// export * from \"./format/index.js\";\n// export * from \"./math/index.js\";\n// export * from \"./utils/index.js\";\n"]}