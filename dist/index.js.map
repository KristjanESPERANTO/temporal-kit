{"version":3,"sources":["../src/guards/index.ts","../src/compare/index.ts","../src/index.ts"],"names":["Temporal"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Type guards for Temporal types\n *\n * These allow runtime type checking and enable TypeScript narrowing.\n */\n\nimport { Temporal } from \"temporal-polyfill\";\nimport type {\n  DateLike,\n  Instant,\n  PlainDate,\n  PlainDateTime,\n  PlainTime,\n  TimeLike,\n  ZonedDateTime,\n} from \"../types/index.js\";\n\n/**\n * Type guard for Temporal.PlainDate\n */\nexport function isPlainDate(value: unknown): value is PlainDate {\n  return value instanceof Temporal.PlainDate;\n}\n\n/**\n * Type guard for Temporal.PlainDateTime\n */\nexport function isPlainDateTime(value: unknown): value is PlainDateTime {\n  return value instanceof Temporal.PlainDateTime;\n}\n\n/**\n * Type guard for Temporal.PlainTime\n */\nexport function isPlainTime(value: unknown): value is PlainTime {\n  return value instanceof Temporal.PlainTime;\n}\n\n/**\n * Type guard for Temporal.ZonedDateTime\n */\nexport function isZonedDateTime(value: unknown): value is ZonedDateTime {\n  return value instanceof Temporal.ZonedDateTime;\n}\n\n/**\n * Type guard for Temporal.Instant\n */\nexport function isInstant(value: unknown): value is Instant {\n  return value instanceof Temporal.Instant;\n}\n\n/**\n * Type guard for DateLike types (PlainDate, PlainDateTime, ZonedDateTime)\n */\nexport function isDateLike(value: unknown): value is DateLike {\n  return (\n    value instanceof Temporal.PlainDate ||\n    value instanceof Temporal.PlainDateTime ||\n    value instanceof Temporal.ZonedDateTime\n  );\n}\n\n/**\n * Type guard for TimeLike types (PlainTime, PlainDateTime, ZonedDateTime)\n */\nexport function isTimeLike(value: unknown): value is TimeLike {\n  return (\n    value instanceof Temporal.PlainTime ||\n    value instanceof Temporal.PlainDateTime ||\n    value instanceof Temporal.ZonedDateTime\n  );\n}\n","/**\n * Comparison functions for Temporal date/time types\n * @module compare\n */\n\nimport { Temporal } from 'temporal-polyfill';\nimport type { DateLike } from '../types/index.js';\n\n/**\n * Checks if the first date/time is before the second.\n *\n * Uses the appropriate compare method based on the type.\n *\n * @param a - First date/time to compare\n * @param b - Second date/time to compare\n * @returns true if a is before b\n *\n * @example\n * ```ts\n * import { isBefore } from 'temporal-kit';\n *\n * const date1 = Temporal.PlainDate.from('2025-01-01');\n * const date2 = Temporal.PlainDate.from('2025-12-31');\n *\n * isBefore(date1, date2); // true\n * ```\n */\nexport function isBefore(a: DateLike, b: DateLike): boolean {\n\t// Use PlainDateTime.compare for DateTime, ZonedDateTime.compare for ZonedDateTime, else PlainDate.compare\n\tif ('hour' in a && 'hour' in b) {\n\t\tif ('timeZoneId' in a && 'timeZoneId' in b) {\n\t\t\treturn Temporal.ZonedDateTime.compare(a, b) < 0;\n\t\t}\n\t\treturn Temporal.PlainDateTime.compare(a, b) < 0;\n\t}\n\treturn Temporal.PlainDate.compare(a, b) < 0;\n}\n\n/**\n * Checks if the first date/time is after the second.\n *\n * Uses the appropriate compare method based on the type.\n *\n * @param a - First date/time to compare\n * @param b - Second date/time to compare\n * @returns true if a is after b\n *\n * @example\n * ```ts\n * import { isAfter } from 'temporal-kit';\n *\n * const date1 = Temporal.PlainDate.from('2025-12-31');\n * const date2 = Temporal.PlainDate.from('2025-01-01');\n *\n * isAfter(date1, date2); // true\n * ```\n */\nexport function isAfter(a: DateLike, b: DateLike): boolean {\n\tif ('hour' in a && 'hour' in b) {\n\t\tif ('timeZoneId' in a && 'timeZoneId' in b) {\n\t\t\treturn Temporal.ZonedDateTime.compare(a, b) > 0;\n\t\t}\n\t\treturn Temporal.PlainDateTime.compare(a, b) > 0;\n\t}\n\treturn Temporal.PlainDate.compare(a, b) > 0;\n}\n\n/**\n * Checks if two date/times are equal.\n *\n * Uses the appropriate compare method based on the type.\n *\n * @param a - First date/time to compare\n * @param b - Second date/time to compare\n * @returns true if a equals b\n *\n * @example\n * ```ts\n * import { isSame } from 'temporal-kit';\n *\n * const date1 = Temporal.PlainDate.from('2025-11-30');\n * const date2 = Temporal.PlainDate.from('2025-11-30');\n *\n * isSame(date1, date2); // true\n * ```\n */\nexport function isSame(a: DateLike, b: DateLike): boolean {\n\tif ('hour' in a && 'hour' in b) {\n\t\tif ('timeZoneId' in a && 'timeZoneId' in b) {\n\t\t\treturn Temporal.ZonedDateTime.compare(a, b) === 0;\n\t\t}\n\t\treturn Temporal.PlainDateTime.compare(a, b) === 0;\n\t}\n\treturn Temporal.PlainDate.compare(a, b) === 0;\n}\n\n/**\n * Returns the earliest (minimum) date/time from the provided values.\n *\n * @param dates - Array of dates to compare\n * @returns The earliest date\n * @throws {TypeError} If the array is empty\n *\n * @example\n * ```ts\n * import { min } from 'temporal-kit';\n *\n * const dates = [\n *   Temporal.PlainDate.from('2025-03-15'),\n *   Temporal.PlainDate.from('2025-01-01'),\n *   Temporal.PlainDate.from('2025-12-31')\n * ];\n *\n * min(dates); // 2025-01-01\n * ```\n */\nexport function min<T extends DateLike>(dates: T[]): T {\n\tif (dates.length === 0) {\n\t\tthrow new TypeError('Cannot find min of empty array');\n\t}\n\n\treturn dates.reduce((earliest, current) => {\n\t\t// Use appropriate compare based on type\n\t\tif ('hour' in current && 'hour' in earliest) {\n\t\t\tif ('timeZoneId' in current && 'timeZoneId' in earliest) {\n\t\t\t\treturn Temporal.ZonedDateTime.compare(current, earliest) < 0 ? current : earliest;\n\t\t\t}\n\t\t\treturn Temporal.PlainDateTime.compare(current, earliest) < 0 ? current : earliest;\n\t\t}\n\t\treturn Temporal.PlainDate.compare(current, earliest) < 0 ? current : earliest;\n\t});\n}\n\n/**\n * Returns the latest (maximum) date/time from the provided values.\n *\n * @param dates - Array of dates to compare\n * @returns The latest date\n * @throws {TypeError} If the array is empty\n *\n * @example\n * ```ts\n * import { max } from 'temporal-kit';\n *\n * const dates = [\n *   Temporal.PlainDate.from('2025-03-15'),\n *   Temporal.PlainDate.from('2025-01-01'),\n *   Temporal.PlainDate.from('2025-12-31')\n * ];\n *\n * max(dates); // 2025-12-31\n * ```\n */\nexport function max<T extends DateLike>(dates: T[]): T {\n\tif (dates.length === 0) {\n\t\tthrow new TypeError('Cannot find max of empty array');\n\t}\n\n\treturn dates.reduce((latest, current) => {\n\t\t// Use appropriate compare based on type\n\t\tif ('hour' in current && 'hour' in latest) {\n\t\t\tif ('timeZoneId' in current && 'timeZoneId' in latest) {\n\t\t\t\treturn Temporal.ZonedDateTime.compare(current, latest) > 0 ? current : latest;\n\t\t\t}\n\t\t\treturn Temporal.PlainDateTime.compare(current, latest) > 0 ? current : latest;\n\t\t}\n\t\treturn Temporal.PlainDate.compare(current, latest) > 0 ? current : latest;\n\t});\n}\n","/**\n * temporal-kit - Main entry point (no polyfill)\n *\n * This entry expects Temporal to be available natively.\n * If you need polyfill support, use 'temporal-kit/polyfilled' instead.\n */\n\n// Check if Temporal is available\nif (typeof (globalThis as { Temporal?: unknown }).Temporal === \"undefined\") {\n  throw new Error(\n    \"Temporal is not available. \" +\n      \"Either use a modern environment with native Temporal support, \" +\n      \"or import from 'temporal-kit/polyfilled' to automatically load the polyfill.\",\n  );\n}\n\n// Re-export guards\nexport * from \"./guards/index.js\";\n// Re-export compare functions\nexport * from \"./compare/index.js\";\n// Re-export types\nexport type * from \"./types/index.js\";\n\n// Placeholder exports for modules we'll implement next\n// export * from \"./compare/index.js\";\n// export * from \"./convert/index.js\";\n// export * from \"./format/index.js\";\n// export * from \"./math/index.js\";\n// export * from \"./utils/index.js\";\n"]}